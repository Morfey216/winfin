{"version":3,"file":"main.js","sources":["../../source/js/general/polyfills.js","../../source/js/general/intersection-observer.js"],"sourcesContent":["// region NodeList.forEach\r\nif (window.NodeList && !NodeList.prototype.forEach) {\r\n  NodeList.prototype.forEach = Array.prototype.forEach;\r\n}\r\n// endregion\r\n\r\n// region Element.matches\r\nif (!Element.prototype.matches) {\r\n  Element.prototype.matches = Element.prototype.msMatchesSelector ||\r\n    Element.prototype.webkitMatchesSelector;\r\n}\r\n// endregion\r\n\r\n// region Element.closest\r\nif (!Element.prototype.closest) {\r\n  Element.prototype.closest = function (s) {\r\n    let el = this;\r\n\r\n    do {\r\n      if (el.matches(s)) {\r\n        return el;\r\n      }\r\n\r\n      el = el.parentElement || el.parentNode;\r\n    } while (el !== null && el.nodeType === 1);\r\n    return null;\r\n  };\r\n}\r\n// endregion\r\n\r\n// region Array.from\r\nif (!Array.from) {\r\n  Array.from = (function () {\r\n    let toStr = Object.prototype.toString;\r\n    let isCallable = function (fn) {\r\n      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';\r\n    };\r\n    let toInteger = function (value) {\r\n      let number = Number(value);\r\n      if (isNaN(number)) {\r\n        return 0;\r\n      }\r\n      if (number === 0 || !isFinite(number)) {\r\n        return number;\r\n      }\r\n      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));\r\n    };\r\n    let maxSafeInteger = Math.pow(2, 53) - 1;\r\n    let toLength = function (value) {\r\n      let len = toInteger(value);\r\n      return Math.min(Math.max(len, 0), maxSafeInteger);\r\n    };\r\n\r\n    // The length property of the from method is 1.\r\n    return function from(arrayLike/*, mapFn, thisArg */) {\r\n      // 1. Let C be the this value.\r\n      let C = this;\r\n\r\n      // 2. Let items be ToObject(arrayLike).\r\n      let items = Object(arrayLike);\r\n\r\n      // 3. ReturnIfAbrupt(items).\r\n      if (arrayLike == null) {\r\n        throw new TypeError('Array.from requires an array-like object - not null or undefined');\r\n      }\r\n\r\n      // 4. If mapfn is undefined, then let mapping be false.\r\n      let mapFn = arguments.length > 1 ? arguments[1] : void undefined;\r\n      let T;\r\n      if (typeof mapFn !== 'undefined') {\r\n        // 5. else\r\n        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.\r\n        if (!isCallable(mapFn)) {\r\n          throw new TypeError('Array.from: when provided, the second argument must be a function');\r\n        }\r\n\r\n        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.\r\n        if (arguments.length > 2) {\r\n          T = arguments[2];\r\n        }\r\n      }\r\n\r\n      // 10. Let lenValue be Get(items, \"length\").\r\n      // 11. Let len be ToLength(lenValue).\r\n      let len = toLength(items.length);\r\n\r\n      // 13. If IsConstructor(C) is true, then\r\n      // 13. a. Let A be the result of calling the [[Construct]] internal method\r\n      // of C with an argument list containing the single item len.\r\n      // 14. a. Else, Let A be ArrayCreate(len).\r\n      let A = isCallable(C) ? Object(new C(len)) : new Array(len);\r\n\r\n      // 16. Let k be 0.\r\n      let k = 0;\r\n      // 17. Repeat, while k < lenâ€¦ (also steps a - h)\r\n      let kValue;\r\n      while (k < len) {\r\n        kValue = items[k];\r\n        if (mapFn) {\r\n          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);\r\n        } else {\r\n          A[k] = kValue;\r\n        }\r\n        k += 1;\r\n      }\r\n      // 18. Let putStatus be Put(A, \"length\", len, true).\r\n      A.length = len;\r\n      // 20. Return A.\r\n      return A;\r\n    };\r\n  }());\r\n}\r\n// endregion\r\n\r\n\r\n// region Placeholder support with .placeholder-shown\r\nfunction placeholderPolyfill() {\r\n  this.classList[this.value ? 'remove' : 'add']('placeholder-shown');\r\n}\r\n\r\ndocument.querySelectorAll('[placeholder]').forEach((el) => {\r\n  el.classList[el.value ? 'remove' : 'add']('placeholder-shown');\r\n  el.addEventListener('change', placeholderPolyfill);\r\n  el.addEventListener('keyup', placeholderPolyfill);\r\n});\r\n// endregion\r\n\r\n// region Array.prototype.includes\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill\r\nif (!Array.prototype.includes) {\r\n  Object.defineProperty(Array.prototype, 'includes', {\r\n    value: function (valueToFind, fromIndex) {\r\n      if (this == null) {\r\n        throw new TypeError('\"this\" is null or not defined');\r\n      }\r\n\r\n      var o = Object(this);\r\n      var len = o.length >>> 0;\r\n\r\n      if (len === 0) {\r\n        return false;\r\n      }\r\n\r\n      var n = fromIndex | 0;\r\n      var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);\r\n\r\n      function sameValueZero(x, y) {\r\n        return x === y || (typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y));\r\n      }\r\n\r\n      while (k < len) {\r\n        if (sameValueZero(o[k], valueToFind)) {\r\n          return true;\r\n        }\r\n        k++;\r\n      }\r\n      return false;\r\n    },\r\n  });\r\n}\r\n// endregion\r\n\r\n// region window.Event\r\n(function () {\r\n  if (typeof window.CustomEvent === 'function') return false;\r\n\r\n  function CustomEvent(event, params) {\r\n    params = params || {bubbles: false, cancelable: false, detail: null};\r\n    var evt = document.createEvent('CustomEvent');\r\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\r\n    return evt;\r\n  }\r\n\r\n  CustomEvent.prototype = window.Event.prototype;\r\n  window.CustomEvent = CustomEvent;\r\n})();\r\n// endregion\r\n\r\n// region Array.prototype.find\r\nif (!Array.prototype.find) {\r\n  Object.defineProperty(Array.prototype, 'find', {\r\n    value: function (predicate) {\r\n      if (this == null) {\r\n        throw new TypeError('\"this\" is null or not defined');\r\n      }\r\n      var o = Object(this);\r\n      var len = o.length >>> 0;\r\n      if (typeof predicate !== 'function') {\r\n        throw new TypeError('predicate must be a function');\r\n      }\r\n      var thisArg = arguments[1];\r\n      var k = 0;\r\n      while (k < len) {\r\n        var kValue = o[k];\r\n        if (predicate.call(thisArg, kValue, k, o)) {\r\n          return kValue;\r\n        }\r\n        k++;\r\n      }\r\n      return undefined;\r\n    },\r\n    configurable: true,\r\n    writable: true,\r\n  });\r\n}\r\n// endregion\r\n","/**\r\n * Copyright 2016 Google Inc. All Rights Reserved.\r\n *\r\n * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.\r\n *\r\n *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\r\n *\r\n */\r\n(function() {\r\n  'use strict';\r\n\r\n// Exit early if we're not running in a browser.\r\n  if (typeof window !== 'object') {\r\n    return;\r\n  }\r\n\r\n// Exit early if all IntersectionObserver and IntersectionObserverEntry\r\n// features are natively supported.\r\n  if ('IntersectionObserver' in window &&\r\n    'IntersectionObserverEntry' in window &&\r\n    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {\r\n\r\n    // Minimal polyfill for Edge 15's lack of `isIntersecting`\r\n    // See: https://github.com/w3c/IntersectionObserver/issues/211\r\n    if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {\r\n      Object.defineProperty(window.IntersectionObserverEntry.prototype,\r\n        'isIntersecting', {\r\n          get: function () {\r\n            return this.intersectionRatio > 0;\r\n          }\r\n        });\r\n    }\r\n    return;\r\n  }\r\n\r\n\r\n  /**\r\n   * A local reference to the document.\r\n   */\r\n  var document = window.document;\r\n\r\n\r\n  /**\r\n   * An IntersectionObserver registry. This registry exists to hold a strong\r\n   * reference to IntersectionObserver instances currently observing a target\r\n   * element. Without this registry, instances without another reference may be\r\n   * garbage collected.\r\n   */\r\n  var registry = [];\r\n\r\n\r\n  /**\r\n   * Creates the global IntersectionObserverEntry constructor.\r\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry\r\n   * @param {Object} entry A dictionary of instance properties.\r\n   * @constructor\r\n   */\r\n  function IntersectionObserverEntry(entry) {\r\n    this.time = entry.time;\r\n    this.target = entry.target;\r\n    this.rootBounds = entry.rootBounds;\r\n    this.boundingClientRect = entry.boundingClientRect;\r\n    this.intersectionRect = entry.intersectionRect || getEmptyRect();\r\n    this.isIntersecting = !!entry.intersectionRect;\r\n\r\n    // Calculates the intersection ratio.\r\n    var targetRect = this.boundingClientRect;\r\n    var targetArea = targetRect.width * targetRect.height;\r\n    var intersectionRect = this.intersectionRect;\r\n    var intersectionArea = intersectionRect.width * intersectionRect.height;\r\n\r\n    // Sets intersection ratio.\r\n    if (targetArea) {\r\n      // Round the intersection ratio to avoid floating point math issues:\r\n      // https://github.com/w3c/IntersectionObserver/issues/324\r\n      this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));\r\n    } else {\r\n      // If area is zero and is intersecting, sets to 1, otherwise to 0\r\n      this.intersectionRatio = this.isIntersecting ? 1 : 0;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Creates the global IntersectionObserver constructor.\r\n   * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface\r\n   * @param {Function} callback The function to be invoked after intersection\r\n   *     changes have queued. The function is not invoked if the queue has\r\n   *     been emptied by calling the `takeRecords` method.\r\n   * @param {Object=} opt_options Optional configuration options.\r\n   * @constructor\r\n   */\r\n  function IntersectionObserver(callback, opt_options) {\r\n\r\n    var options = opt_options || {};\r\n\r\n    if (typeof callback != 'function') {\r\n      throw new Error('callback must be a function');\r\n    }\r\n\r\n    if (options.root && options.root.nodeType != 1) {\r\n      throw new Error('root must be an Element');\r\n    }\r\n\r\n    // Binds and throttles `this._checkForIntersections`.\r\n    this._checkForIntersections = throttle(\r\n      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);\r\n\r\n    // Private properties.\r\n    this._callback = callback;\r\n    this._observationTargets = [];\r\n    this._queuedEntries = [];\r\n    this._rootMarginValues = this._parseRootMargin(options.rootMargin);\r\n\r\n    // Public properties.\r\n    this.thresholds = this._initThresholds(options.threshold);\r\n    this.root = options.root || null;\r\n    this.rootMargin = this._rootMarginValues.map(function(margin) {\r\n      return margin.value + margin.unit;\r\n    }).join(' ');\r\n  }\r\n\r\n\r\n  /**\r\n   * The minimum interval within which the document will be checked for\r\n   * intersection changes.\r\n   */\r\n  IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;\r\n\r\n\r\n  /**\r\n   * The frequency in which the polyfill polls for intersection changes.\r\n   * this can be updated on a per instance basis and must be set prior to\r\n   * calling `observe` on the first target.\r\n   */\r\n  IntersectionObserver.prototype.POLL_INTERVAL = null;\r\n\r\n  /**\r\n   * Use a mutation observer on the root element\r\n   * to detect intersection changes.\r\n   */\r\n  IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;\r\n\r\n\r\n  /**\r\n   * Starts observing a target element for intersection changes based on\r\n   * the thresholds values.\r\n   * @param {Element} target The DOM element to observe.\r\n   */\r\n  IntersectionObserver.prototype.observe = function(target) {\r\n    var isTargetAlreadyObserved = this._observationTargets.some(function(item) {\r\n      return item.element == target;\r\n    });\r\n\r\n    if (isTargetAlreadyObserved) {\r\n      return;\r\n    }\r\n\r\n    if (!(target && target.nodeType == 1)) {\r\n      throw new Error('target must be an Element');\r\n    }\r\n\r\n    this._registerInstance();\r\n    this._observationTargets.push({element: target, entry: null});\r\n    this._monitorIntersections();\r\n    this._checkForIntersections();\r\n  };\r\n\r\n\r\n  /**\r\n   * Stops observing a target element for intersection changes.\r\n   * @param {Element} target The DOM element to observe.\r\n   */\r\n  IntersectionObserver.prototype.unobserve = function(target) {\r\n    this._observationTargets =\r\n      this._observationTargets.filter(function(item) {\r\n\r\n        return item.element != target;\r\n      });\r\n    if (!this._observationTargets.length) {\r\n      this._unmonitorIntersections();\r\n      this._unregisterInstance();\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Stops observing all target elements for intersection changes.\r\n   */\r\n  IntersectionObserver.prototype.disconnect = function() {\r\n    this._observationTargets = [];\r\n    this._unmonitorIntersections();\r\n    this._unregisterInstance();\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns any queue entries that have not yet been reported to the\r\n   * callback and clears the queue. This can be used in conjunction with the\r\n   * callback to obtain the absolute most up-to-date intersection information.\r\n   * @return {Array} The currently queued entries.\r\n   */\r\n  IntersectionObserver.prototype.takeRecords = function() {\r\n    var records = this._queuedEntries.slice();\r\n    this._queuedEntries = [];\r\n    return records;\r\n  };\r\n\r\n\r\n  /**\r\n   * Accepts the threshold value from the user configuration object and\r\n   * returns a sorted array of unique threshold values. If a value is not\r\n   * between 0 and 1 and error is thrown.\r\n   * @private\r\n   * @param {Array|number=} opt_threshold An optional threshold value or\r\n   *     a list of threshold values, defaulting to [0].\r\n   * @return {Array} A sorted list of unique and valid threshold values.\r\n   */\r\n  IntersectionObserver.prototype._initThresholds = function(opt_threshold) {\r\n    var threshold = opt_threshold || [0];\r\n    if (!Array.isArray(threshold)) threshold = [threshold];\r\n\r\n    return threshold.sort().filter(function(t, i, a) {\r\n      if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {\r\n        throw new Error('threshold must be a number between 0 and 1 inclusively');\r\n      }\r\n      return t !== a[i - 1];\r\n    });\r\n  };\r\n\r\n\r\n  /**\r\n   * Accepts the rootMargin value from the user configuration object\r\n   * and returns an array of the four margin values as an object containing\r\n   * the value and unit properties. If any of the values are not properly\r\n   * formatted or use a unit other than px or %, and error is thrown.\r\n   * @private\r\n   * @param {string=} opt_rootMargin An optional rootMargin value,\r\n   *     defaulting to '0px'.\r\n   * @return {Array<Object>} An array of margin objects with the keys\r\n   *     value and unit.\r\n   */\r\n  IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {\r\n    var marginString = opt_rootMargin || '0px';\r\n    var margins = marginString.split(/\\s+/).map(function(margin) {\r\n      var parts = /^(-?\\d*\\.?\\d+)(px|%)$/.exec(margin);\r\n      if (!parts) {\r\n        throw new Error('rootMargin must be specified in pixels or percent');\r\n      }\r\n      return {value: parseFloat(parts[1]), unit: parts[2]};\r\n    });\r\n\r\n    // Handles shorthand.\r\n    margins[1] = margins[1] || margins[0];\r\n    margins[2] = margins[2] || margins[0];\r\n    margins[3] = margins[3] || margins[1];\r\n\r\n    return margins;\r\n  };\r\n\r\n\r\n  /**\r\n   * Starts polling for intersection changes if the polling is not already\r\n   * happening, and if the page's visibility state is visible.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._monitorIntersections = function() {\r\n    if (!this._monitoringIntersections) {\r\n      this._monitoringIntersections = true;\r\n\r\n      // If a poll interval is set, use polling instead of listening to\r\n      // resize and scroll events or DOM mutations.\r\n      if (this.POLL_INTERVAL) {\r\n        this._monitoringInterval = setInterval(\r\n          this._checkForIntersections, this.POLL_INTERVAL);\r\n      }\r\n      else {\r\n        addEvent(window, 'resize', this._checkForIntersections, true);\r\n        addEvent(document, 'scroll', this._checkForIntersections, true);\r\n\r\n        if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in window) {\r\n          this._domObserver = new MutationObserver(this._checkForIntersections);\r\n          this._domObserver.observe(document, {\r\n            attributes: true,\r\n            childList: true,\r\n            characterData: true,\r\n            subtree: true\r\n          });\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Stops polling for intersection changes.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._unmonitorIntersections = function() {\r\n    if (this._monitoringIntersections) {\r\n      this._monitoringIntersections = false;\r\n\r\n      clearInterval(this._monitoringInterval);\r\n      this._monitoringInterval = null;\r\n\r\n      removeEvent(window, 'resize', this._checkForIntersections, true);\r\n      removeEvent(document, 'scroll', this._checkForIntersections, true);\r\n\r\n      if (this._domObserver) {\r\n        this._domObserver.disconnect();\r\n        this._domObserver = null;\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Scans each observation target for intersection changes and adds them\r\n   * to the internal entries queue. If new entries are found, it\r\n   * schedules the callback to be invoked.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._checkForIntersections = function() {\r\n    var rootIsInDom = this._rootIsInDom();\r\n    var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();\r\n\r\n    this._observationTargets.forEach(function(item) {\r\n      var target = item.element;\r\n      var targetRect = getBoundingClientRect(target);\r\n      var rootContainsTarget = this._rootContainsTarget(target);\r\n      var oldEntry = item.entry;\r\n      var intersectionRect = rootIsInDom && rootContainsTarget &&\r\n        this._computeTargetAndRootIntersection(target, rootRect);\r\n\r\n      var newEntry = item.entry = new IntersectionObserverEntry({\r\n        time: now(),\r\n        target: target,\r\n        boundingClientRect: targetRect,\r\n        rootBounds: rootRect,\r\n        intersectionRect: intersectionRect\r\n      });\r\n\r\n      if (!oldEntry) {\r\n        this._queuedEntries.push(newEntry);\r\n      } else if (rootIsInDom && rootContainsTarget) {\r\n        // If the new entry intersection ratio has crossed any of the\r\n        // thresholds, add a new entry.\r\n        if (this._hasCrossedThreshold(oldEntry, newEntry)) {\r\n          this._queuedEntries.push(newEntry);\r\n        }\r\n      } else {\r\n        // If the root is not in the DOM or target is not contained within\r\n        // root but the previous entry for this target had an intersection,\r\n        // add a new record indicating removal.\r\n        if (oldEntry && oldEntry.isIntersecting) {\r\n          this._queuedEntries.push(newEntry);\r\n        }\r\n      }\r\n    }, this);\r\n\r\n    if (this._queuedEntries.length) {\r\n      this._callback(this.takeRecords(), this);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Accepts a target and root rect computes the intersection between then\r\n   * following the algorithm in the spec.\r\n   * TODO(philipwalton): at this time clip-path is not considered.\r\n   * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo\r\n   * @param {Element} target The target DOM element\r\n   * @param {Object} rootRect The bounding rect of the root after being\r\n   *     expanded by the rootMargin value.\r\n   * @return {?Object} The final intersection rect object or undefined if no\r\n   *     intersection is found.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._computeTargetAndRootIntersection =\r\n    function(target, rootRect) {\r\n\r\n      // If the element isn't displayed, an intersection can't happen.\r\n      if (window.getComputedStyle(target).display == 'none') return;\r\n\r\n      var targetRect = getBoundingClientRect(target);\r\n      var intersectionRect = targetRect;\r\n      var parent = getParentNode(target);\r\n      var atRoot = false;\r\n\r\n      while (!atRoot) {\r\n        var parentRect = null;\r\n        var parentComputedStyle = parent.nodeType == 1 ?\r\n          window.getComputedStyle(parent) : {};\r\n\r\n        // If the parent isn't displayed, an intersection can't happen.\r\n        if (parentComputedStyle.display == 'none') return;\r\n\r\n        if (parent == this.root || parent == document) {\r\n          atRoot = true;\r\n          parentRect = rootRect;\r\n        } else {\r\n          // If the element has a non-visible overflow, and it's not the <body>\r\n          // or <html> element, update the intersection rect.\r\n          // Note: <body> and <html> cannot be clipped to a rect that's not also\r\n          // the document rect, so no need to compute a new intersection.\r\n          if (parent != document.body &&\r\n            parent != document.documentElement &&\r\n            parentComputedStyle.overflow != 'visible') {\r\n            parentRect = getBoundingClientRect(parent);\r\n          }\r\n        }\r\n\r\n        // If either of the above conditionals set a new parentRect,\r\n        // calculate new intersection data.\r\n        if (parentRect) {\r\n          intersectionRect = computeRectIntersection(parentRect, intersectionRect);\r\n\r\n          if (!intersectionRect) break;\r\n        }\r\n        parent = getParentNode(parent);\r\n      }\r\n      return intersectionRect;\r\n    };\r\n\r\n\r\n  /**\r\n   * Returns the root rect after being expanded by the rootMargin value.\r\n   * @return {Object} The expanded root rect.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._getRootRect = function() {\r\n    var rootRect;\r\n    if (this.root) {\r\n      rootRect = getBoundingClientRect(this.root);\r\n    } else {\r\n      // Use <html>/<body> instead of window since scroll bars affect size.\r\n      var html = document.documentElement;\r\n      var body = document.body;\r\n      rootRect = {\r\n        top: 0,\r\n        left: 0,\r\n        right: html.clientWidth || body.clientWidth,\r\n        width: html.clientWidth || body.clientWidth,\r\n        bottom: html.clientHeight || body.clientHeight,\r\n        height: html.clientHeight || body.clientHeight\r\n      };\r\n    }\r\n    return this._expandRectByRootMargin(rootRect);\r\n  };\r\n\r\n\r\n  /**\r\n   * Accepts a rect and expands it by the rootMargin value.\r\n   * @param {Object} rect The rect object to expand.\r\n   * @return {Object} The expanded rect.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {\r\n    var margins = this._rootMarginValues.map(function(margin, i) {\r\n      return margin.unit == 'px' ? margin.value :\r\n        margin.value * (i % 2 ? rect.width : rect.height) / 100;\r\n    });\r\n    var newRect = {\r\n      top: rect.top - margins[0],\r\n      right: rect.right + margins[1],\r\n      bottom: rect.bottom + margins[2],\r\n      left: rect.left - margins[3]\r\n    };\r\n    newRect.width = newRect.right - newRect.left;\r\n    newRect.height = newRect.bottom - newRect.top;\r\n\r\n    return newRect;\r\n  };\r\n\r\n\r\n  /**\r\n   * Accepts an old and new entry and returns true if at least one of the\r\n   * threshold values has been crossed.\r\n   * @param {?IntersectionObserverEntry} oldEntry The previous entry for a\r\n   *    particular target element or null if no previous entry exists.\r\n   * @param {IntersectionObserverEntry} newEntry The current entry for a\r\n   *    particular target element.\r\n   * @return {boolean} Returns true if a any threshold has been crossed.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._hasCrossedThreshold =\r\n    function(oldEntry, newEntry) {\r\n\r\n      // To make comparing easier, an entry that has a ratio of 0\r\n      // but does not actually intersect is given a value of -1\r\n      var oldRatio = oldEntry && oldEntry.isIntersecting ?\r\n        oldEntry.intersectionRatio || 0 : -1;\r\n      var newRatio = newEntry.isIntersecting ?\r\n        newEntry.intersectionRatio || 0 : -1;\r\n\r\n      // Ignore unchanged ratios\r\n      if (oldRatio === newRatio) return;\r\n\r\n      for (var i = 0; i < this.thresholds.length; i++) {\r\n        var threshold = this.thresholds[i];\r\n\r\n        // Return true if an entry matches a threshold or if the new ratio\r\n        // and the old ratio are on the opposite sides of a threshold.\r\n        if (threshold == oldRatio || threshold == newRatio ||\r\n          threshold < oldRatio !== threshold < newRatio) {\r\n          return true;\r\n        }\r\n      }\r\n    };\r\n\r\n\r\n  /**\r\n   * Returns whether or not the root element is an element and is in the DOM.\r\n   * @return {boolean} True if the root element is an element and is in the DOM.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._rootIsInDom = function() {\r\n    return !this.root || containsDeep(document, this.root);\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns whether or not the target element is a child of root.\r\n   * @param {Element} target The target element to check.\r\n   * @return {boolean} True if the target element is a child of root.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._rootContainsTarget = function(target) {\r\n    return containsDeep(this.root || document, target);\r\n  };\r\n\r\n\r\n  /**\r\n   * Adds the instance to the global IntersectionObserver registry if it isn't\r\n   * already present.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._registerInstance = function() {\r\n    if (registry.indexOf(this) < 0) {\r\n      registry.push(this);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Removes the instance from the global IntersectionObserver registry.\r\n   * @private\r\n   */\r\n  IntersectionObserver.prototype._unregisterInstance = function() {\r\n    var index = registry.indexOf(this);\r\n    if (index != -1) registry.splice(index, 1);\r\n  };\r\n\r\n\r\n  /**\r\n   * Returns the result of the performance.now() method or null in browsers\r\n   * that don't support the API.\r\n   * @return {number} The elapsed time since the page was requested.\r\n   */\r\n  function now() {\r\n    return window.performance && performance.now && performance.now();\r\n  }\r\n\r\n\r\n  /**\r\n   * Throttles a function and delays its execution, so it's only called at most\r\n   * once within a given time period.\r\n   * @param {Function} fn The function to throttle.\r\n   * @param {number} timeout The amount of time that must pass before the\r\n   *     function can be called again.\r\n   * @return {Function} The throttled function.\r\n   */\r\n  function throttle(fn, timeout) {\r\n    var timer = null;\r\n    return function () {\r\n      if (!timer) {\r\n        timer = setTimeout(function() {\r\n          fn();\r\n          timer = null;\r\n        }, timeout);\r\n      }\r\n    };\r\n  }\r\n\r\n\r\n  /**\r\n   * Adds an event handler to a DOM node ensuring cross-browser compatibility.\r\n   * @param {Node} node The DOM node to add the event handler to.\r\n   * @param {string} event The event name.\r\n   * @param {Function} fn The event handler to add.\r\n   * @param {boolean} opt_useCapture Optionally adds the even to the capture\r\n   *     phase. Note: this only works in modern browsers.\r\n   */\r\n  function addEvent(node, event, fn, opt_useCapture) {\r\n    if (typeof node.addEventListener == 'function') {\r\n      node.addEventListener(event, fn, opt_useCapture || false);\r\n    }\r\n    else if (typeof node.attachEvent == 'function') {\r\n      node.attachEvent('on' + event, fn);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Removes a previously added event handler from a DOM node.\r\n   * @param {Node} node The DOM node to remove the event handler from.\r\n   * @param {string} event The event name.\r\n   * @param {Function} fn The event handler to remove.\r\n   * @param {boolean} opt_useCapture If the event handler was added with this\r\n   *     flag set to true, it should be set to true here in order to remove it.\r\n   */\r\n  function removeEvent(node, event, fn, opt_useCapture) {\r\n    if (typeof node.removeEventListener == 'function') {\r\n      node.removeEventListener(event, fn, opt_useCapture || false);\r\n    }\r\n    else if (typeof node.detatchEvent == 'function') {\r\n      node.detatchEvent('on' + event, fn);\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns the intersection between two rect objects.\r\n   * @param {Object} rect1 The first rect.\r\n   * @param {Object} rect2 The second rect.\r\n   * @return {?Object} The intersection rect or undefined if no intersection\r\n   *     is found.\r\n   */\r\n  function computeRectIntersection(rect1, rect2) {\r\n    var top = Math.max(rect1.top, rect2.top);\r\n    var bottom = Math.min(rect1.bottom, rect2.bottom);\r\n    var left = Math.max(rect1.left, rect2.left);\r\n    var right = Math.min(rect1.right, rect2.right);\r\n    var width = right - left;\r\n    var height = bottom - top;\r\n\r\n    return (width >= 0 && height >= 0) && {\r\n      top: top,\r\n      bottom: bottom,\r\n      left: left,\r\n      right: right,\r\n      width: width,\r\n      height: height\r\n    };\r\n  }\r\n\r\n\r\n  /**\r\n   * Shims the native getBoundingClientRect for compatibility with older IE.\r\n   * @param {Element} el The element whose bounding rect to get.\r\n   * @return {Object} The (possibly shimmed) rect of the element.\r\n   */\r\n  function getBoundingClientRect(el) {\r\n    var rect;\r\n\r\n    try {\r\n      rect = el.getBoundingClientRect();\r\n    } catch (err) {\r\n      // Ignore Windows 7 IE11 \"Unspecified error\"\r\n      // https://github.com/w3c/IntersectionObserver/pull/205\r\n    }\r\n\r\n    if (!rect) return getEmptyRect();\r\n\r\n    // Older IE\r\n    if (!(rect.width && rect.height)) {\r\n      rect = {\r\n        top: rect.top,\r\n        right: rect.right,\r\n        bottom: rect.bottom,\r\n        left: rect.left,\r\n        width: rect.right - rect.left,\r\n        height: rect.bottom - rect.top\r\n      };\r\n    }\r\n    return rect;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns an empty rect object. An empty rect is returned when an element\r\n   * is not in the DOM.\r\n   * @return {Object} The empty rect.\r\n   */\r\n  function getEmptyRect() {\r\n    return {\r\n      top: 0,\r\n      bottom: 0,\r\n      left: 0,\r\n      right: 0,\r\n      width: 0,\r\n      height: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Checks to see if a parent element contains a child element (including inside\r\n   * shadow DOM).\r\n   * @param {Node} parent The parent element.\r\n   * @param {Node} child The child element.\r\n   * @return {boolean} True if the parent node contains the child node.\r\n   */\r\n  function containsDeep(parent, child) {\r\n    var node = child;\r\n    while (node) {\r\n      if (node == parent) return true;\r\n\r\n      node = getParentNode(node);\r\n    }\r\n    return false;\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets the parent node of an element or its host element if the parent node\r\n   * is a shadow root.\r\n   * @param {Node} node The node whose parent to get.\r\n   * @return {Node|null} The parent node or null if no parent exists.\r\n   */\r\n  function getParentNode(node) {\r\n    var parent = node.parentNode;\r\n\r\n    if (parent && parent.nodeType == 11 && parent.host) {\r\n      // If the parent is a shadow root, return the host element.\r\n      return parent.host;\r\n    }\r\n\r\n    if (parent && parent.assignedSlot) {\r\n      // If the parent is distributed in a <slot>, return the parent of a slot.\r\n      return parent.assignedSlot.parentNode;\r\n    }\r\n\r\n    return parent;\r\n  }\r\n\r\n\r\n// Exposes the constructors globally.\r\n  window.IntersectionObserver = IntersectionObserver;\r\n  window.IntersectionObserverEntry = IntersectionObserverEntry;\r\n\r\n}());\r\n"],"names":["isCallable","fn","toStr","call","toLength","value","number","len","Number","isNaN","isFinite","Math","floor","abs","min","max","maxSafeInteger","placeholderPolyfill","classList","this","CustomEvent","event","params","bubbles","cancelable","detail","evt","document","createEvent","initCustomEvent","window","NodeList","prototype","forEach","Array","Element","matches","msMatchesSelector","webkitMatchesSelector","closest","s","el","parentElement","parentNode","nodeType","from","Object","toString","pow","arrayLike","items","TypeError","T","mapFn","arguments","length","kValue","A","k","querySelectorAll","addEventListener","includes","defineProperty","valueToFind","fromIndex","o","x","y","n","Event","find","predicate","thisArg","configurable","writable","IntersectionObserverEntry","get","intersectionRatio","IntersectionObserver","THROTTLE_TIMEOUT","POLL_INTERVAL","USE_MUTATION_OBSERVER","observe","target","_observationTargets","some","item","element","Error","_registerInstance","push","entry","_monitorIntersections","_checkForIntersections","unobserve","filter","_unmonitorIntersections","_unregisterInstance","disconnect","takeRecords","records","_queuedEntries","slice","_initThresholds","opt_threshold","threshold","isArray","sort","t","i","a","_parseRootMargin","opt_rootMargin","margins","split","map","margin","parts","exec","parseFloat","unit","_monitoringIntersections","_monitoringInterval","setInterval","addEvent","_domObserver","MutationObserver","attributes","childList","characterData","subtree","clearInterval","removeEvent","rootIsInDom","_rootIsInDom","rootRect","_getRootRect","getEmptyRect","targetRect","getBoundingClientRect","rootContainsTarget","_rootContainsTarget","oldEntry","intersectionRect","_computeTargetAndRootIntersection","newEntry","time","performance","now","boundingClientRect","rootBounds","_hasCrossedThreshold","isIntersecting","_callback","getComputedStyle","display","rect1","rect2","top","bottom","left","right","width","height","parent","getParentNode","atRoot","parentRect","parentComputedStyle","root","body","documentElement","overflow","html","clientWidth","clientHeight","_expandRectByRootMargin","rect","_rootMarginValues","newRect","oldRatio","newRatio","thresholds","containsDeep","targetArea","intersectionArea","toFixed","callback","opt_options","timeout","timer","options","bind","setTimeout","rootMargin","join","node","opt_useCapture","attachEvent","removeEventListener","detatchEvent","err","child","host","assignedSlot"],"mappings":"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"}